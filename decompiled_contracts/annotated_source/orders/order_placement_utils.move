/// ============================================================================
/// ORDER PLACEMENT UTILS - Order Placement with Callback Actions
/// ============================================================================
///
/// This module provides utility functions for placing orders and executing
/// the resulting callback actions. It bridges the perp_market order placement
/// with the clearinghouse callbacks system.
///
/// KEY FUNCTIONS:
/// - place_order_and_trigger_matching_actions: Place an order and execute callbacks
/// - invoke_callback_actions: Execute cancel/reduce actions from matching
///
/// CALLBACK ACTIONS:
/// When orders are placed or matched, the matching engine may generate actions
/// that need to be executed (e.g., cancel reduce-only orders that exceed position).
/// This module handles executing those actions.
///
/// ============================================================================

module decibel::order_placement_utils {
    use std::vector;
    use std::string;
    use std::option;
    use std::object;

    use decibel::perp_market;
    use decibel::perp_engine_types;
    use decibel::clearinghouse_perp;
    use econia::market_types;
    use econia::order_book_types;
    use econia::order_placement;
    use econia::single_order_types;

    // ============================================================================
    // Friend Declarations
    // ============================================================================

    friend decibel::liquidation;
    friend decibel::async_matching_engine;

    // ============================================================================
    // ORDER PLACEMENT
    // ============================================================================

    /// Place an order and trigger any resulting matching actions
    ///
    /// This is the main order placement function used by the trading system.
    /// It places an order on the order book and executes any callback actions
    /// generated by the matching process.
    ///
    /// # Parameters
    /// - `market`: The perpetual market
    /// - `account`: The account placing the order
    /// - `size`: Order size in base units
    /// - `price`: Order price
    /// - `trigger_price_delta`: Price delta for trigger orders
    /// - `is_long`: True for buy, false for sell
    /// - `time_in_force`: Order time-in-force (GTC, IOC, FOK, etc.)
    /// - `trigger_condition`: Optional trigger condition for conditional orders
    /// - `metadata`: Order metadata (reduce-only flags, TP/SL, etc.)
    /// - `order_id`: Pre-generated order ID
    /// - `client_order_id`: Optional client-provided order ID
    /// - `is_taker_order`: True if this is a taker (market) order
    /// - `remaining_matches`: Mutable counter for remaining matches allowed
    ///
    /// # Returns
    /// - `order_id`: The final order ID
    /// - `filled_size`: Amount filled immediately
    /// - `cancellation_reason`: If order was cancelled, the reason
    /// - `match_prices`: Vector of prices at which fills occurred
    /// - `num_matches`: Number of matches that occurred
    friend fun place_order_and_trigger_matching_actions(
        market: object::Object<perp_market::PerpMarket>,
        account: address,
        size: u64,
        price: u64,
        trigger_price_delta: u64,
        is_long: bool,
        time_in_force: order_book_types::TimeInForce,
        trigger_condition: option::Option<order_book_types::TriggerCondition>,
        metadata: perp_engine_types::OrderMetadata,
        order_id: order_book_types::OrderIdType,
        client_order_id: option::Option<string::String>,
        is_taker_order: bool,
        remaining_matches: &mut u32
    ): (
        order_book_types::OrderIdType,  // Final order ID
        u64,                             // Filled size
        option::Option<market_types::OrderCancellationReason>,  // Cancellation reason
        vector<u64>,                     // Match prices
        u32                              // Number of matches
    ) {
        // Get market callbacks for clearinghouse integration
        let callbacks = clearinghouse_perp::market_callbacks(market);

        // Get current remaining matches
        let current_remaining = *remaining_matches;

        // Place order on the order book
        let match_result = perp_market::place_order_with_order_id(
            market,
            account,
            size,
            price,
            trigger_price_delta,
            is_long,
            time_in_force,
            trigger_condition,
            metadata,
            order_id,
            client_order_id,
            current_remaining,
            false,  // is_liquidation
            is_taker_order,
            &callbacks
        );

        // Destructure match result
        let (
            final_order_id,
            filled_size,
            cancellation_reason,
            matching_actions,
            match_prices,
            num_matches
        ) = order_placement::destroy_order_match_result<perp_engine_types::OrderMatchingActions>(match_result);

        // Verify match count is valid
        let num_matches_u64 = num_matches as u64;
        let match_prices_len = vector::length<u64>(&match_prices);
        assert!(num_matches_u64 >= match_prices_len, 1);

        // Update remaining matches counter
        if (num_matches == 0u32) {
            *remaining_matches = *remaining_matches - 1u32;
        } else {
            *remaining_matches = *remaining_matches - num_matches;
        };

        // Execute callback actions (cancel/reduce orders as needed)
        invoke_callback_actions(matching_actions, &callbacks, market);

        (final_order_id, filled_size, cancellation_reason, match_prices, num_matches)
    }

    // ============================================================================
    // CALLBACK ACTION EXECUTION
    // ============================================================================

    /// Invoke callback actions generated by order matching
    ///
    /// During order matching, the clearinghouse may generate actions that need
    /// to be executed afterwards. These include:
    /// - CancelOrder: Cancel an existing order (e.g., reduce-only exceeds position)
    /// - ReduceOrderSize: Reduce the size of an existing order
    ///
    /// # Parameters
    /// - `actions`: Vector of order matching actions to execute
    /// - `callbacks`: Market clearinghouse callbacks
    /// - `market`: The perpetual market
    fun invoke_callback_actions(
        actions: vector<perp_engine_types::OrderMatchingActions>,
        callbacks: &market_types::MarketClearinghouseCallbacks<perp_engine_types::OrderMetadata, perp_engine_types::OrderMatchingActions>,
        market: object::Object<perp_market::PerpMarket>
    ) {
        // Reverse to process in FIFO order
        let mut actions_vec = actions;
        vector::reverse<perp_engine_types::OrderMatchingActions>(&mut actions_vec);

        let mut remaining = vector::length<perp_engine_types::OrderMatchingActions>(&actions_vec);

        while (remaining > 0) {
            // Get the next batch of actions
            let matching_actions = vector::pop_back<perp_engine_types::OrderMatchingActions>(&mut actions_vec);
            let mut single_actions = perp_engine_types::destroy_order_matching_actions(matching_actions);

            // Reverse to process in FIFO order
            vector::reverse<perp_engine_types::SingleOrderAction>(&mut single_actions);

            let mut action_count = vector::length<perp_engine_types::SingleOrderAction>(&single_actions);

            while (action_count > 0) {
                let action = vector::pop_back<perp_engine_types::SingleOrderAction>(&mut single_actions);

                if (perp_engine_types::is_cancel_order_action(&action)) {
                    // Cancel order action
                    let (account, order_id) = perp_engine_types::destroy_cancel_order_action(action);

                    // Cancel with "cancelled by user" reason (reduce-only enforcement)
                    let reason = market_types::order_cancellation_reason_cancelled_by_user();
                    let empty_msg = string::utf8(vector[]);

                    let _cancelled = perp_market::try_cancel_order(
                        market,
                        account,
                        order_id,
                        true,  // emit_event
                        reason,
                        empty_msg,
                        callbacks
                    );
                } else if (perp_engine_types::is_reduce_order_size_action(&action)) {
                    // Reduce order size action
                    let (account, order_id, size_delta) = perp_engine_types::destroy_reduce_order_size_action(action);

                    perp_market::decrease_order_size(
                        market,
                        account,
                        order_id,
                        size_delta,
                        callbacks
                    );
                };

                action_count = action_count - 1;
            };

            vector::destroy_empty<perp_engine_types::SingleOrderAction>(single_actions);
            remaining = remaining - 1;
        };

        vector::destroy_empty<perp_engine_types::OrderMatchingActions>(actions_vec);
    }
}
